/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dataview-uniq.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_mode_t_Initialize(asn1SccFrame_mode_t* pVal)
{
    *pVal = (asn1SccFrame_mode_t) asn1Sccmode_undefined;
}
#endif

 
flag asn1SccFrame_mode_t_IsConstraintValid(const asn1SccFrame_mode_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((((((((((((*pVal == asn1Sccmode_undefined) || (*pVal == asn1Sccmode_grayscale)) || (*pVal == asn1Sccmode_rgb)) || (*pVal == asn1Sccmode_uyvy)) || (*pVal == asn1Sccmode_bgr)) || (*pVal == asn1Sccmode_rgb32)) || (*pVal == asn1Sccraw_modes)) || (*pVal == asn1Sccmode_bayer)) || (*pVal == asn1Sccmode_bayer_rggb)) || (*pVal == asn1Sccmode_bayer_grbg)) || (*pVal == asn1Sccmode_bayer_bggr)) || (*pVal == asn1Sccmode_bayer_gbrg)) || (*pVal == asn1Scccompressed_modes)) || (*pVal == asn1SccFrame_mode_t_mode_pjpg)) || (*pVal == asn1Sccmode_jpeg)) || (*pVal == asn1Sccmode_png));
	*pErrCode = ret ? 0 : ERR_asn1SccFrame_mode_t;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_status_t_Initialize(asn1SccFrame_status_t* pVal)
{
    *pVal = (asn1SccFrame_status_t) asn1Sccstatus_empty;
}
#endif

 
flag asn1SccFrame_status_t_IsConstraintValid(const asn1SccFrame_status_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccstatus_empty) || (*pVal == asn1Sccstatus_valid)) || (*pVal == asn1Sccstatus_invalid));
	*pErrCode = ret ? 0 : ERR_asn1SccFrame_status_t;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_image_Initialize(asn1SccFrame_image* pVal)
{
    *pVal = (asn1SccFrame_image) {0,
    {
    }
};
}
#endif

 
flag asn1SccFrame_image_IsConstraintValid(const asn1SccFrame_image* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)frameMaxBytes);
	*pErrCode = ret ? 0 : ERR_asn1SccFrame_image;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLASER_RANGE_ERRORS_Initialize(asn1SccLASER_RANGE_ERRORS* pVal)
{
    *pVal = (asn1SccLASER_RANGE_ERRORS) asn1SccLASER_RANGE_ERRORS_too_far;
}
#endif

 
flag asn1SccLASER_RANGE_ERRORS_IsConstraintValid(const asn1SccLASER_RANGE_ERRORS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((*pVal == asn1SccLASER_RANGE_ERRORS_too_far) || (*pVal == asn1SccLASER_RANGE_ERRORS_too_near)) || (*pVal == asn1SccLASER_RANGE_ERRORS_measurement_error)) || (*pVal == asn1Sccother_range_errors)) || (*pVal == asn1Sccmax_range_error)) || (*pVal == asn1Sccend_laser_range_errors));
	*pErrCode = ret ? 0 : ERR_asn1SccLASER_RANGE_ERRORS;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
    *pVal = (asn1SccT_Int32) -2147483648LL;
}
#endif

 
flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int32;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLaserScan_ranges_Initialize(asn1SccLaserScan_ranges* pVal)
{
    *pVal = (asn1SccLaserScan_ranges) {    .nCount = 1,    .arr = 
    {
        -2147483648LL        
    }
};
}
#endif

 
flag asn1SccLaserScan_ranges_IsConstraintValid(const asn1SccLaserScan_ranges* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxLaserScanSize);
	*pErrCode = ret ? 0 : ERR_asn1SccLaserScan_ranges;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
    *pVal = (asn1SccT_UInt32) 0;
}
#endif

 
flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt32;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccInvalidTimeStep_Initialize(asn1SccInvalidTimeStep* pVal)
{
    *pVal = (asn1SccInvalidTimeStep) {
    .time_step = 0
};
}
#endif

 
flag asn1SccInvalidTimeStep_IsConstraintValid(const asn1SccInvalidTimeStep* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_UInt32_IsConstraintValid(&pVal->time_step, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
    *pVal = (asn1SccT_Int8) -128;
}
#endif

 
flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-128 <= *pVal && *pVal <= 127);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int8;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
    *pVal = (asn1SccT_UInt8) 0;
}
#endif

 
flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 255);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt8;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonarBeam_beam_Initialize(asn1SccSonarBeam_beam* pVal)
{
    *pVal = (asn1SccSonarBeam_beam) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccSonarBeam_beam_IsConstraintValid(const asn1SccSonarBeam_beam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxSonarBeamSize);
	*pErrCode = ret ? 0 : ERR_asn1SccSonarBeam_beam;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccCompressedFrame_image_Initialize(asn1SccCompressedFrame_image* pVal)
{
    *pVal = (asn1SccCompressedFrame_image) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccCompressedFrame_image_IsConstraintValid(const asn1SccCompressedFrame_image* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxCompressedFrameImageSize);
	*pErrCode = ret ? 0 : ERR_asn1SccCompressedFrame_image;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonarScan_data_Initialize(asn1SccSonarScan_data* pVal)
{
    *pVal = (asn1SccSonarScan_data) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccSonarScan_data_IsConstraintValid(const asn1SccSonarScan_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxSonarScanDataSize);
	*pErrCode = ret ? 0 : ERR_asn1SccSonarScan_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
    *pVal = (asn1SccT_Boolean) FALSE;
}
#endif

 
flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVizkitFilePath_Initialize(asn1SccVizkitFilePath pVal)
{
    static asn1SccVizkitFilePath ret = 
        "";
    strcpy(pVal, ret);
}
#endif

 
flag asn1SccVizkitFilePath_IsConstraintValid(const asn1SccVizkitFilePath pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= strlen(pVal) && strlen(pVal) <= (int)vizkit3dPathMaxSize);
	*pErrCode = ret ? 0 : ERR_asn1SccVizkitFilePath;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVizkitPluginLabel_Initialize(asn1SccVizkitPluginLabel pVal)
{
    static asn1SccVizkitPluginLabel ret = 
        " ";
    strcpy(pVal, ret);
}
#endif

 
flag asn1SccVizkitPluginLabel_IsConstraintValid(const asn1SccVizkitPluginLabel pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= strlen(pVal) && strlen(pVal) <= (int)vizkit3dLabelMaxSize);
	*pErrCode = ret ? 0 : ERR_asn1SccVizkitPluginLabel;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Double_Initialize(asn1SccT_Double* pVal)
{
    *pVal = (asn1SccT_Double) 0.00000000000000000000E+000;
}
#endif

 
flag asn1SccT_Double_IsConstraintValid(const asn1SccT_Double* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-1.79769313486231570000E+308 <= *pVal && *pVal <= 1.79769313486231570000E+308);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Double;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector6d_Initialize(asn1SccVector6d* pVal)
{
    *pVal = (asn1SccVector6d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector6d_IsConstraintValid(const asn1SccVector6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccVector6d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector3d_Initialize(asn1SccVector3d* pVal)
{
    *pVal = (asn1SccVector3d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector3d_IsConstraintValid(const asn1SccVector3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccVector3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPoint_Initialize(asn1SccPoint* pVal)
{
    *pVal = (asn1SccPoint) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccPoint_IsConstraintValid(const asn1SccPoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTrajectory_points_Initialize(asn1SccTrajectory_points* pVal)
{
    *pVal = (asn1SccTrajectory_points) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccTrajectory_points_IsConstraintValid(const asn1SccTrajectory_points* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxTrajectoryPoints);
	*pErrCode = ret ? 0 : ERR_asn1SccTrajectory_points;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccPoint_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTrajectory_Initialize(asn1SccTrajectory* pVal)
{
    *pVal = (asn1SccTrajectory) {
    .speed = 0.00000000000000000000E+000,
    .points = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccTrajectory_IsConstraintValid(const asn1SccTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	if (ret) {
	    ret = asn1SccTrajectory_points_IsConstraintValid(&pVal->points, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPointcloud_points_Initialize(asn1SccPointcloud_points* pVal)
{
    *pVal = (asn1SccPointcloud_points) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccPointcloud_points_IsConstraintValid(const asn1SccPointcloud_points* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxPointcloudSize);
	*pErrCode = ret ? 0 : ERR_asn1SccPointcloud_points;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccPoint_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPosition_Initialize(asn1SccPosition* pVal)
{
    *pVal = (asn1SccPosition) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccPosition_IsConstraintValid(const asn1SccPosition* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWaypoint_Initialize(asn1SccWaypoint* pVal)
{
    *pVal = (asn1SccWaypoint) {
    .position = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .heading = 0.00000000000000000000E+000,
    .tol_position = 0.00000000000000000000E+000,
    .tol_heading = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccWaypoint_IsConstraintValid(const asn1SccWaypoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->heading, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_position, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_heading, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccQuaterniond_Initialize(asn1SccQuaterniond* pVal)
{
    *pVal = (asn1SccQuaterniond) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccQuaterniond_IsConstraintValid(const asn1SccQuaterniond* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccQuaterniond;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccOrientation_Initialize(asn1SccOrientation* pVal)
{
    *pVal = (asn1SccOrientation) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccOrientation_IsConstraintValid(const asn1SccOrientation* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccQuaterniond_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPose_Initialize(asn1SccPose* pVal)
{
    *pVal = (asn1SccPose) {
    .pos = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .orient = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccPose_IsConstraintValid(const asn1SccPose* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPosition_IsConstraintValid(&pVal->pos, pErrCode);
	if (ret) {
	    ret = asn1SccOrientation_IsConstraintValid(&pVal->orient, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVectorXd_Initialize(asn1SccVectorXd* pVal)
{
    *pVal = (asn1SccVectorXd) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVectorXd_IsConstraintValid(const asn1SccVectorXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 100);
	*pErrCode = ret ? 0 : ERR_asn1SccVectorXd;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector2d_Initialize(asn1SccVector2d* pVal)
{
    *pVal = (asn1SccVector2d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector2d_IsConstraintValid(const asn1SccVector2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 2);
	*pErrCode = ret ? 0 : ERR_asn1SccVector2d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPosition2D_Initialize(asn1SccPosition2D* pVal)
{
    *pVal = (asn1SccPosition2D) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccPosition2D_IsConstraintValid(const asn1SccPosition2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector2d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPose2D_Initialize(asn1SccPose2D* pVal)
{
    *pVal = (asn1SccPose2D) {
    .position = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .orientation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccPose2D_IsConstraintValid(const asn1SccPose2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPosition2D_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector4d_Initialize(asn1SccVector4d* pVal)
{
    *pVal = (asn1SccVector4d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector4d_IsConstraintValid(const asn1SccVector4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccVector4d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPointcloud_colors_Initialize(asn1SccPointcloud_colors* pVal)
{
    *pVal = (asn1SccPointcloud_colors) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccPointcloud_colors_IsConstraintValid(const asn1SccPointcloud_colors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxPointcloudSize);
	*pErrCode = ret ? 0 : ERR_asn1SccPointcloud_colors;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccVector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAngleAxisd_Initialize(asn1SccAngleAxisd* pVal)
{
    *pVal = (asn1SccAngleAxisd) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccAngleAxisd_IsConstraintValid(const asn1SccAngleAxisd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccAngleAxisd;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTransform3d_elm_Initialize(asn1SccTransform3d_elm* pVal)
{
    *pVal = (asn1SccTransform3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccTransform3d_elm_IsConstraintValid(const asn1SccTransform3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccTransform3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTransform3d_Initialize(asn1SccTransform3d* pVal)
{
    *pVal = (asn1SccTransform3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccTransform3d_IsConstraintValid(const asn1SccTransform3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccTransform3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTransform3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix4d_elm_Initialize(asn1SccMatrix4d_elm* pVal)
{
    *pVal = (asn1SccMatrix4d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix4d_elm_IsConstraintValid(const asn1SccMatrix4d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix4d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix4d_Initialize(asn1SccMatrix4d* pVal)
{
    *pVal = (asn1SccMatrix4d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix4d_IsConstraintValid(const asn1SccMatrix4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix4d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix4d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix2d_elm_Initialize(asn1SccMatrix2d_elm* pVal)
{
    *pVal = (asn1SccMatrix2d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix2d_elm_IsConstraintValid(const asn1SccMatrix2d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 2);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix2d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix2d_Initialize(asn1SccMatrix2d* pVal)
{
    *pVal = (asn1SccMatrix2d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix2d_IsConstraintValid(const asn1SccMatrix2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 2);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix2d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix2d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccIsometry3d_elm_Initialize(asn1SccIsometry3d_elm* pVal)
{
    *pVal = (asn1SccIsometry3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccIsometry3d_elm_IsConstraintValid(const asn1SccIsometry3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccIsometry3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccIsometry3d_Initialize(asn1SccIsometry3d* pVal)
{
    *pVal = (asn1SccIsometry3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccIsometry3d_IsConstraintValid(const asn1SccIsometry3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccIsometry3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccIsometry3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrixXd_elm_Initialize(asn1SccMatrixXd_elm* pVal)
{
    *pVal = (asn1SccMatrixXd_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrixXd_elm_IsConstraintValid(const asn1SccMatrixXd_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 20);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrixXd_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrixXd_Initialize(asn1SccMatrixXd* pVal)
{
    *pVal = (asn1SccMatrixXd) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrixXd_IsConstraintValid(const asn1SccMatrixXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 20);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrixXd;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrixXd_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix3d_elm_Initialize(asn1SccMatrix3d_elm* pVal)
{
    *pVal = (asn1SccMatrix3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix3d_elm_IsConstraintValid(const asn1SccMatrix3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix3d_Initialize(asn1SccMatrix3d* pVal)
{
    *pVal = (asn1SccMatrix3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix3d_IsConstraintValid(const asn1SccMatrix3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix6d_elm_Initialize(asn1SccMatrix6d_elm* pVal)
{
    *pVal = (asn1SccMatrix6d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix6d_elm_IsConstraintValid(const asn1SccMatrix6d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix6d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix6d_Initialize(asn1SccMatrix6d* pVal)
{
    *pVal = (asn1SccMatrix6d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix6d_IsConstraintValid(const asn1SccMatrix6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix6d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix6d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccCovariance_Initialize(asn1SccCovariance* pVal)
{
    *pVal = (asn1SccCovariance) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccCovariance_IsConstraintValid(const asn1SccCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccMatrix6d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTwistWithCovariance_Initialize(asn1SccTwistWithCovariance* pVal)
{
    *pVal = (asn1SccTwistWithCovariance) {
    .vel = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .rot = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccTwistWithCovariance_IsConstraintValid(const asn1SccTwistWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(&pVal->vel, pErrCode);
	if (ret) {
	    ret = asn1SccVector3d_IsConstraintValid(&pVal->rot, pErrCode);
	    if (ret) {
	        ret = asn1SccCovariance_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTransformWithCovariance_Initialize(asn1SccTransformWithCovariance* pVal)
{
    *pVal = (asn1SccTransformWithCovariance) {
    .translation = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .orientation = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccTransformWithCovariance_IsConstraintValid(const asn1SccTransformWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPosition_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccQuaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	    if (ret) {
	        ret = asn1SccCovariance_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAffine3d_elm_Initialize(asn1SccAffine3d_elm* pVal)
{
    *pVal = (asn1SccAffine3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccAffine3d_elm_IsConstraintValid(const asn1SccAffine3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccAffine3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAffine3d_Initialize(asn1SccAffine3d* pVal)
{
    *pVal = (asn1SccAffine3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccAffine3d_IsConstraintValid(const asn1SccAffine3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccAffine3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccAffine3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAngle_Initialize(asn1SccAngle* pVal)
{
    *pVal = (asn1SccAngle) {
    .rad = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccAngle_IsConstraintValid(const asn1SccAngle* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->rad, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonar_bearings_Initialize(asn1SccSonar_bearings* pVal)
{
    *pVal = (asn1SccSonar_bearings) {    .nCount = 1,    .arr = 
    {
        {
            .rad = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccSonar_bearings_IsConstraintValid(const asn1SccSonar_bearings* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxSonarSize);
	*pErrCode = ret ? 0 : ERR_asn1SccSonar_bearings;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccAngle_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAngleSegment_Initialize(asn1SccAngleSegment* pVal)
{
    *pVal = (asn1SccAngleSegment) {
    .startRad = 0.00000000000000000000E+000,
    .width = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccAngleSegment_IsConstraintValid(const asn1SccAngleSegment* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->startRad, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->width, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPoseUpdateThreshold_Initialize(asn1SccPoseUpdateThreshold* pVal)
{
    *pVal = (asn1SccPoseUpdateThreshold) {
    .distance = 0.00000000000000000000E+000,
    .angle = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccPoseUpdateThreshold_IsConstraintValid(const asn1SccPoseUpdateThreshold* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->distance, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->angle, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_horizontal_interval_Initialize(asn1SccDepthMap_horizontal_interval* pVal)
{
    *pVal = (asn1SccDepthMap_horizontal_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_horizontal_interval_IsConstraintValid(const asn1SccDepthMap_horizontal_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_horizontal_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_vertical_interval_Initialize(asn1SccDepthMap_vertical_interval* pVal)
{
    *pVal = (asn1SccDepthMap_vertical_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_vertical_interval_IsConstraintValid(const asn1SccDepthMap_vertical_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_vertical_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMotion2D_Initialize(asn1SccMotion2D* pVal)
{
    *pVal = (asn1SccMotion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccMotion2D_IsConstraintValid(const asn1SccMotion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTemperature_Initialize(asn1SccTemperature* pVal)
{
    *pVal = (asn1SccTemperature) {
    .kelvin = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccTemperature_IsConstraintValid(const asn1SccTemperature* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->kelvin, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Float_Initialize(asn1SccT_Float* pVal)
{
    *pVal = (asn1SccT_Float) 0.00000000000000000000E+000;
}
#endif

 
flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-3.40282346600000020000E+038 <= *pVal && *pVal <= 3.40282346600000020000E+038);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Float;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLaserScan_remission_Initialize(asn1SccLaserScan_remission* pVal)
{
    *pVal = (asn1SccLaserScan_remission) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccLaserScan_remission_IsConstraintValid(const asn1SccLaserScan_remission* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxLaserScanSize);
	*pErrCode = ret ? 0 : ERR_asn1SccLaserScan_remission;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonar_bins_Initialize(asn1SccSonar_bins* pVal)
{
    *pVal = (asn1SccSonar_bins) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccSonar_bins_IsConstraintValid(const asn1SccSonar_bins* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxSonarSize);
	*pErrCode = ret ? 0 : ERR_asn1SccSonar_bins;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointState_Initialize(asn1SccJointState* pVal)
{
    *pVal = (asn1SccJointState) {
    .position = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .effort = 0.00000000000000000000E+000,
    .raw = 0.00000000000000000000E+000,
    .acceleration = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccJointState_IsConstraintValid(const asn1SccJointState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->speed, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Float_IsConstraintValid(&pVal->effort, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->raw, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointTrajectory_Initialize(asn1SccJointTrajectory* pVal)
{
    *pVal = (asn1SccJointTrajectory) {    .nCount = 1,    .arr = 
    {
        {
            .position = 0.00000000000000000000E+000,
            .speed = 0.00000000000000000000E+000,
            .effort = 0.00000000000000000000E+000,
            .raw = 0.00000000000000000000E+000,
            .acceleration = 0.00000000000000000000E+000
        }        
    }
};
}
#endif

 
flag asn1SccJointTrajectory_IsConstraintValid(const asn1SccJointTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxJointTrajectorySize);
	*pErrCode = ret ? 0 : ERR_asn1SccJointTrajectory;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccJointState_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointsTrajectory_trajectory_Initialize(asn1SccJointsTrajectory_trajectory* pVal)
{
    *pVal = (asn1SccJointsTrajectory_trajectory) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }        
            }
        }        
    }
};
}
#endif

 
flag asn1SccJointsTrajectory_trajectory_IsConstraintValid(const asn1SccJointsTrajectory_trajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxJointsTrajectorySize);
	*pErrCode = ret ? 0 : ERR_asn1SccJointsTrajectory_trajectory;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccJointTrajectory_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJoints_elements_Initialize(asn1SccJoints_elements* pVal)
{
    *pVal = (asn1SccJoints_elements) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccJoints_elements_IsConstraintValid(const asn1SccJoints_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)jointsElementsMax);
	*pErrCode = ret ? 0 : ERR_asn1SccJoints_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccJointState_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointLimitRange_Initialize(asn1SccJointLimitRange* pVal)
{
    *pVal = (asn1SccJointLimitRange) {
    .min = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    },
    .max = {
        .position = 0.00000000000000000000E+000,
        .speed = 0.00000000000000000000E+000,
        .effort = 0.00000000000000000000E+000,
        .raw = 0.00000000000000000000E+000,
        .acceleration = 0.00000000000000000000E+000
    }
};
}
#endif

 
flag asn1SccJointLimitRange_IsConstraintValid(const asn1SccJointLimitRange* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccJointState_IsConstraintValid(&pVal->min, pErrCode);
	if (ret) {
	    ret = asn1SccJointState_IsConstraintValid(&pVal->max, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointLimits_ranges_Initialize(asn1SccJointLimits_ranges* pVal)
{
    *pVal = (asn1SccJointLimits_ranges) {    .nCount = 1,    .arr = 
    {
        {
            .min = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            },
            .max = {
                .position = 0.00000000000000000000E+000,
                .speed = 0.00000000000000000000E+000,
                .effort = 0.00000000000000000000E+000,
                .raw = 0.00000000000000000000E+000,
                .acceleration = 0.00000000000000000000E+000
            }
        }        
    }
};
}
#endif

 
flag asn1SccJointLimits_ranges_IsConstraintValid(const asn1SccJointLimits_ranges* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxJointLimitsSize);
	*pErrCode = ret ? 0 : ERR_asn1SccJointLimits_ranges;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccJointLimitRange_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDistanceImage_data_Initialize(asn1SccDistanceImage_data* pVal)
{
    *pVal = (asn1SccDistanceImage_data) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDistanceImage_data_IsConstraintValid(const asn1SccDistanceImage_data* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDistanceImageSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDistanceImage_data;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_remissions_Initialize(asn1SccDepthMap_remissions* pVal)
{
    *pVal = (asn1SccDepthMap_remissions) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_remissions_IsConstraintValid(const asn1SccDepthMap_remissions* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_remissions;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_distances_Initialize(asn1SccDepthMap_distances* pVal)
{
    *pVal = (asn1SccDepthMap_distances) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_distances_IsConstraintValid(const asn1SccDepthMap_distances* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_distances;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int16_Initialize(asn1SccT_Int16* pVal)
{
    *pVal = (asn1SccT_Int16) -32768;
}
#endif

 
flag asn1SccT_Int16_IsConstraintValid(const asn1SccT_Int16* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-32768 <= *pVal && *pVal <= 32767);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int16;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt16_Initialize(asn1SccT_UInt16* pVal)
{
    *pVal = (asn1SccT_UInt16) 0;
}
#endif

 
flag asn1SccT_UInt16_IsConstraintValid(const asn1SccT_UInt16* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 65535);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt16;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_size_t_Initialize(asn1SccFrame_size_t* pVal)
{
    *pVal = (asn1SccFrame_size_t) {
    .width = 0,
    .height = 0
};
}
#endif

 
flag asn1SccFrame_size_t_IsConstraintValid(const asn1SccFrame_size_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_UInt16_IsConstraintValid(&pVal->width, pErrCode);
	if (ret) {
	    ret = asn1SccT_UInt16_IsConstraintValid(&pVal->height, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt64_Initialize(asn1SccT_UInt64* pVal)
{
    *pVal = (asn1SccT_UInt64) 0;
}
#endif

 
flag asn1SccT_UInt64_IsConstraintValid(const asn1SccT_UInt64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt64;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int64_Initialize(asn1SccT_Int64* pVal)
{
    *pVal = (asn1SccT_Int64) -9223372036854775807LL;
}
#endif

 
flag asn1SccT_Int64_IsConstraintValid(const asn1SccT_Int64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-9223372036854775807LL <= *pVal && *pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int64;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTime_Initialize(asn1SccTime* pVal)
{
    *pVal = (asn1SccTime) {
    .microseconds = -9223372036854775807LL,
    .usecPerSec = -2147483648LL
};
}
#endif

 
flag asn1SccTime_IsConstraintValid(const asn1SccTime* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Int64_IsConstraintValid(&pVal->microseconds, pErrCode);
	if (ret) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->usecPerSec, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonarBeam_Initialize(asn1SccSonarBeam* pVal)
{
    *pVal = (asn1SccSonarBeam) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .bearing = {
        .rad = 0.00000000000000000000E+000
    },
    .sampling_interval = 0.00000000000000000000E+000,
    .speed_of_sound = 0.00000000000000000000E+000,
    .beamwidth_horizontal = 0.00000000000000000000E+000,
    .beamwidth_vertical = 0.00000000000000000000E+000,
    .beam = {    .nCount = 1,    .arr = 
        {
            0        
        }
    }
};
}
#endif

 
flag asn1SccSonarBeam_IsConstraintValid(const asn1SccSonarBeam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccAngle_IsConstraintValid(&pVal->bearing, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->sampling_interval, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_horizontal, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_vertical, pErrCode);
	                    if (ret) {
	                        ret = asn1SccSonarBeam_beam_IsConstraintValid(&pVal->beam, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointsTrajectory_timetags_Initialize(asn1SccJointsTrajectory_timetags* pVal)
{
    *pVal = (asn1SccJointsTrajectory_timetags) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        }        
    }
};
}
#endif

 
flag asn1SccJointsTrajectory_timetags_IsConstraintValid(const asn1SccJointsTrajectory_timetags* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxJointsTrajectorySize);
	*pErrCode = ret ? 0 : ERR_asn1SccJointsTrajectory_timetags;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLaserScan_Initialize(asn1SccLaserScan* pVal)
{
    *pVal = (asn1SccLaserScan) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .start_angle = 0.00000000000000000000E+000,
    .angular_resolution = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .ranges = {    .nCount = 1,    .arr = 
        {
            -2147483648LL        
        }
    },
    .minRange = 0,
    .maxRange = 0,
    .remission = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccLaserScan_IsConstraintValid(const asn1SccLaserScan* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->start_angle, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->angular_resolution, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	            if (ret) {
	                ret = asn1SccLaserScan_ranges_IsConstraintValid(&pVal->ranges, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->minRange, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->maxRange, pErrCode);
	                        if (ret) {
	                            ret = asn1SccLaserScan_remission_IsConstraintValid(&pVal->remission, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonar_timestamps_Initialize(asn1SccSonar_timestamps* pVal)
{
    *pVal = (asn1SccSonar_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        }        
    }
};
}
#endif

 
flag asn1SccSonar_timestamps_IsConstraintValid(const asn1SccSonar_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxSonarSize);
	*pErrCode = ret ? 0 : ERR_asn1SccSonar_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonar_Initialize(asn1SccSonar* pVal)
{
    *pVal = (asn1SccSonar) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL,
                .usecPerSec = -2147483648LL
            }        
        }
    },
    .bin_duration = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .beam_width = {
        .rad = 0.00000000000000000000E+000
    },
    .beam_height = {
        .rad = 0.00000000000000000000E+000
    },
    .bearings = {    .nCount = 1,    .arr = 
        {
            {
                .rad = 0.00000000000000000000E+000
            }        
        }
    },
    .speed_of_sound = 0.00000000000000000000E+000,
    .bin_count = 0,
    .beam_count = 0,
    .bins = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccSonar_IsConstraintValid(const asn1SccSonar* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccSonar_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccTime_IsConstraintValid(&pVal->bin_duration, pErrCode);
	        if (ret) {
	            ret = asn1SccAngle_IsConstraintValid(&pVal->beam_width, pErrCode);
	            if (ret) {
	                ret = asn1SccAngle_IsConstraintValid(&pVal->beam_height, pErrCode);
	                if (ret) {
	                    ret = asn1SccSonar_bearings_IsConstraintValid(&pVal->bearings, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->bin_count, pErrCode);
	                            if (ret) {
	                                ret = asn1SccT_UInt32_IsConstraintValid(&pVal->beam_count, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccSonar_bins_IsConstraintValid(&pVal->bins, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrench_Initialize(asn1SccWrench* pVal)
{
    *pVal = (asn1SccWrench) {
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .force = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .torque = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccWrench_IsConstraintValid(const asn1SccWrench* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	if (ret) {
	    ret = asn1SccVector3d_IsConstraintValid(&pVal->force, pErrCode);
	    if (ret) {
	        ret = asn1SccVector3d_IsConstraintValid(&pVal->torque, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrenches_wrenches_Initialize(asn1SccWrenches_wrenches* pVal)
{
    *pVal = (asn1SccWrenches_wrenches) {    .nCount = 1,    .arr = 
    {
        {
            .timestamp = {
                .microseconds = -9223372036854775807LL,
                .usecPerSec = -2147483648LL
            },
            .force = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            },
            .torque = {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccWrenches_wrenches_IsConstraintValid(const asn1SccWrenches_wrenches* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxWrenchesSize);
	*pErrCode = ret ? 0 : ERR_asn1SccWrenches_wrenches;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccWrench_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDistanceImage_Initialize(asn1SccDistanceImage* pVal)
{
    *pVal = (asn1SccDistanceImage) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .width = 0,
    .height = 0,
    .scale_x = 0.00000000000000000000E+000,
    .scale_y = 0.00000000000000000000E+000,
    .center_x = 0.00000000000000000000E+000,
    .center_y = 0.00000000000000000000E+000,
    .data = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccDistanceImage_IsConstraintValid(const asn1SccDistanceImage* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccT_UInt16_IsConstraintValid(&pVal->width, pErrCode);
	    if (ret) {
	        ret = asn1SccT_UInt16_IsConstraintValid(&pVal->height, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->scale_x, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->scale_y, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Float_IsConstraintValid(&pVal->center_x, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_Float_IsConstraintValid(&pVal->center_y, pErrCode);
	                        if (ret) {
	                            ret = asn1SccDistanceImage_data_IsConstraintValid(&pVal->data, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccRigidBodyAcceleration_Initialize(asn1SccRigidBodyAcceleration* pVal)
{
    *pVal = (asn1SccRigidBodyAcceleration) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .acceleration = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_acceleration = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccRigidBodyAcceleration_IsConstraintValid(const asn1SccRigidBodyAcceleration* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccVector3d_IsConstraintValid(&pVal->acceleration, pErrCode);
	    if (ret) {
	        ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_acceleration, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPressure_Initialize(asn1SccPressure* pVal)
{
    *pVal = (asn1SccPressure) {
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .pascals = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccPressure_IsConstraintValid(const asn1SccPressure* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->pascals, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_timestamps_Initialize(asn1SccDepthMap_timestamps* pVal)
{
    *pVal = (asn1SccDepthMap_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        }        
    }
};
}
#endif

 
flag asn1SccDepthMap_timestamps_IsConstraintValid(const asn1SccDepthMap_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccIMUSensors_Initialize(asn1SccIMUSensors* pVal)
{
    *pVal = (asn1SccIMUSensors) {
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .acc = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .gyro = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .mag = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccIMUSensors_IsConstraintValid(const asn1SccIMUSensors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	if (ret) {
	    ret = asn1SccVector3d_IsConstraintValid(&pVal->acc, pErrCode);
	    if (ret) {
	        ret = asn1SccVector3d_IsConstraintValid(&pVal->gyro, pErrCode);
	        if (ret) {
	            ret = asn1SccVector3d_IsConstraintValid(&pVal->mag, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBodyState_Initialize(asn1SccBodyState* pVal)
{
    *pVal = (asn1SccBodyState) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .pose = {
        .translation = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .orientation = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .cov = {    .nCount = 1,    .arr = 
            {
                {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }        
            }
        }
    },
    .velocity = {
        .vel = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .rot = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .cov = {    .nCount = 1,    .arr = 
            {
                {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }        
            }
        }
    }
};
}
#endif

 
flag asn1SccBodyState_IsConstraintValid(const asn1SccBodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccTransformWithCovariance_IsConstraintValid(&pVal->pose, pErrCode);
	    if (ret) {
	        ret = asn1SccTwistWithCovariance_IsConstraintValid(&pVal->velocity, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPointcloud_Initialize(asn1SccPointcloud* pVal)
{
    *pVal = (asn1SccPointcloud) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .points = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .colors = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccPointcloud_IsConstraintValid(const asn1SccPointcloud* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccPointcloud_points_IsConstraintValid(&pVal->points, pErrCode);
	    if (ret) {
	        ret = asn1SccPointcloud_colors_IsConstraintValid(&pVal->colors, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonarScan_time_beams_Initialize(asn1SccSonarScan_time_beams* pVal)
{
    *pVal = (asn1SccSonarScan_time_beams) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        }        
    }
};
}
#endif

 
flag asn1SccSonarScan_time_beams_IsConstraintValid(const asn1SccSonarScan_time_beams* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxSonarScanDataSize);
	*pErrCode = ret ? 0 : ERR_asn1SccSonarScan_time_beams;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonarScan_Initialize(asn1SccSonarScan* pVal)
{
    *pVal = (asn1SccSonarScan) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .data = {    .nCount = 1,    .arr = 
        {
            0        
        }
    },
    .time_beams = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL,
                .usecPerSec = -2147483648LL
            }        
        }
    },
    .number_of_beams = 0,
    .number_of_bins = 0,
    .start_bearing = {
        .rad = 0.00000000000000000000E+000
    },
    .angular_resolution = {
        .rad = 0.00000000000000000000E+000
    },
    .sampling_interval = 0.00000000000000000000E+000,
    .speed_of_sound = 0.00000000000000000000E+000,
    .beamwidth_horizontal = {
        .rad = 0.00000000000000000000E+000
    },
    .beamwidth_vertical = {
        .rad = 0.00000000000000000000E+000
    },
    .memory_layout_column = FALSE,
    .polar_coordinates = FALSE
};
}
#endif

 
flag asn1SccSonarScan_IsConstraintValid(const asn1SccSonarScan* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccSonarScan_data_IsConstraintValid(&pVal->data, pErrCode);
	    if (ret) {
	        ret = asn1SccSonarScan_time_beams_IsConstraintValid(&pVal->time_beams, pErrCode);
	        if (ret) {
	            ret = asn1SccT_UInt16_IsConstraintValid(&pVal->number_of_beams, pErrCode);
	            if (ret) {
	                ret = asn1SccT_UInt16_IsConstraintValid(&pVal->number_of_bins, pErrCode);
	                if (ret) {
	                    ret = asn1SccAngle_IsConstraintValid(&pVal->start_bearing, pErrCode);
	                    if (ret) {
	                        ret = asn1SccAngle_IsConstraintValid(&pVal->angular_resolution, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_Double_IsConstraintValid(&pVal->sampling_interval, pErrCode);
	                            if (ret) {
	                                ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccAngle_IsConstraintValid(&pVal->beamwidth_horizontal, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccAngle_IsConstraintValid(&pVal->beamwidth_vertical, pErrCode);
	                                        if (ret) {
	                                            ret = asn1SccT_Boolean_IsConstraintValid(&pVal->memory_layout_column, pErrCode);
	                                            if (ret) {
	                                                ret = asn1SccT_Boolean_IsConstraintValid(&pVal->polar_coordinates, pErrCode);
	                                            
	                                            }
	                                        }
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_String_Initialize(asn1SccT_String* pVal)
{
    *pVal = (asn1SccT_String) {0,
    {
    }
};
}
#endif

 
flag asn1SccT_String_IsConstraintValid(const asn1SccT_String* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)maxSize_T_String);
	*pErrCode = ret ? 0 : ERR_asn1SccT_String;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointLimits_Initialize(asn1SccJointLimits* pVal)
{
    *pVal = (asn1SccJointLimits) {
    .vector_name = {0,
        {
        }
    },
    .ranges = {    .nCount = 1,    .arr = 
        {
            {
                .min = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                },
                .max = {
                    .position = 0.00000000000000000000E+000,
                    .speed = 0.00000000000000000000E+000,
                    .effort = 0.00000000000000000000E+000,
                    .raw = 0.00000000000000000000E+000,
                    .acceleration = 0.00000000000000000000E+000
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccJointLimits_IsConstraintValid(const asn1SccJointLimits* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->vector_name, pErrCode);
	if (ret) {
	    ret = asn1SccJointLimits_ranges_IsConstraintValid(&pVal->ranges, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_attrib_t_Initialize(asn1SccFrame_attrib_t* pVal)
{
    *pVal = (asn1SccFrame_attrib_t) {
    .data = {0,
        {
        }
    },
    .att_name = {0,
        {
        }
    }
};
}
#endif

 
flag asn1SccFrame_attrib_t_IsConstraintValid(const asn1SccFrame_attrib_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->data, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->att_name, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_attributes_Initialize(asn1SccFrame_attributes* pVal)
{
    *pVal = (asn1SccFrame_attributes) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccFrame_attributes_IsConstraintValid(const asn1SccFrame_attributes* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)frameMaxAttributes);
	*pErrCode = ret ? 0 : ERR_asn1SccFrame_attributes;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccFrame_attrib_t_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_Initialize(asn1SccFrame* pVal)
{
    *pVal = (asn1SccFrame) {
    .frame_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .received_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .image = {0,
        {
        }
    },
    .attributes = {    .nCount = 0,    .arr = 
        {
            
        }
    },
    .datasize = {
        .width = 0,
        .height = 0
    },
    .data_depth = 0,
    .pixel_size = 0,
    .row_size = 0,
    .frame_mode = asn1Sccmode_undefined,
    .frame_status = asn1Sccstatus_empty
};
}
#endif

 
flag asn1SccFrame_IsConstraintValid(const asn1SccFrame* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->frame_time, pErrCode);
	if (ret) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->received_time, pErrCode);
	    if (ret) {
	        ret = asn1SccFrame_image_IsConstraintValid(&pVal->image, pErrCode);
	        if (ret) {
	            ret = asn1SccFrame_attributes_IsConstraintValid(&pVal->attributes, pErrCode);
	            if (ret) {
	                ret = asn1SccFrame_size_t_IsConstraintValid(&pVal->datasize, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->data_depth, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->pixel_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->row_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccFrame_mode_t_IsConstraintValid(&pVal->frame_mode, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccFrame_status_t_IsConstraintValid(&pVal->frame_status, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFramePair_Initialize(asn1SccFramePair* pVal)
{
    *pVal = (asn1SccFramePair) {
    .frame_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .first = {
        .frame_time = {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        },
        .received_time = {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        },
        .image = {0,
            {
            }
        },
        .attributes = {    .nCount = 0,    .arr = 
            {
                
            }
        },
        .datasize = {
            .width = 0,
            .height = 0
        },
        .data_depth = 0,
        .pixel_size = 0,
        .row_size = 0,
        .frame_mode = asn1Sccmode_undefined,
        .frame_status = asn1Sccstatus_empty
    },
    .second = {
        .frame_time = {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        },
        .received_time = {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        },
        .image = {0,
            {
            }
        },
        .attributes = {    .nCount = 0,    .arr = 
            {
                
            }
        },
        .datasize = {
            .width = 0,
            .height = 0
        },
        .data_depth = 0,
        .pixel_size = 0,
        .row_size = 0,
        .frame_mode = asn1Sccmode_undefined,
        .frame_status = asn1Sccstatus_empty
    },
    .id = 0
};
}
#endif

 
flag asn1SccFramePair_IsConstraintValid(const asn1SccFramePair* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->frame_time, pErrCode);
	if (ret) {
	    ret = asn1SccFrame_IsConstraintValid(&pVal->first, pErrCode);
	    if (ret) {
	        ret = asn1SccFrame_IsConstraintValid(&pVal->second, pErrCode);
	        if (ret) {
	            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->id, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccCompressedFrame_attributes_Initialize(asn1SccCompressedFrame_attributes* pVal)
{
    *pVal = (asn1SccCompressedFrame_attributes) {    .nCount = 1,    .arr = 
    {
        {
            .data = {0,
                {
                }
            },
            .att_name = {0,
                {
                }
            }
        }        
    }
};
}
#endif

 
flag asn1SccCompressedFrame_attributes_IsConstraintValid(const asn1SccCompressedFrame_attributes* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxCompressedFrameImageAttributes);
	*pErrCode = ret ? 0 : ERR_asn1SccCompressedFrame_attributes;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccFrame_attrib_t_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointsTrajectory_Initialize(asn1SccJointsTrajectory* pVal)
{
    *pVal = (asn1SccJointsTrajectory) {
    .vector_name = {0,
        {
        }
    },
    .timetags = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL,
                .usecPerSec = -2147483648LL
            }        
        }
    },
    .trajectory = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    {
                        .position = 0.00000000000000000000E+000,
                        .speed = 0.00000000000000000000E+000,
                        .effort = 0.00000000000000000000E+000,
                        .raw = 0.00000000000000000000E+000,
                        .acceleration = 0.00000000000000000000E+000
                    }        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccJointsTrajectory_IsConstraintValid(const asn1SccJointsTrajectory* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->vector_name, pErrCode);
	if (ret) {
	    ret = asn1SccJointsTrajectory_timetags_IsConstraintValid(&pVal->timetags, pErrCode);
	    if (ret) {
	        ret = asn1SccJointsTrajectory_trajectory_IsConstraintValid(&pVal->trajectory, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJoints_names_Initialize(asn1SccJoints_names* pVal)
{
    *pVal = (asn1SccJoints_names) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccJoints_names_IsConstraintValid(const asn1SccJoints_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)jointsElementsMax);
	*pErrCode = ret ? 0 : ERR_asn1SccJoints_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJoints_Initialize(asn1SccJoints* pVal)
{
    *pVal = (asn1SccJoints) {
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .names = {    .nCount = 0,    .arr = 
        {
            
        }
    },
    .elements = {    .nCount = 0,    .arr = 
        {
            
        }
    }
};
}
#endif

 
flag asn1SccJoints_IsConstraintValid(const asn1SccJoints* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	if (ret) {
	    ret = asn1SccJoints_names_IsConstraintValid(&pVal->names, pErrCode);
	    if (ret) {
	        ret = asn1SccJoints_elements_IsConstraintValid(&pVal->elements, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccOutOfBounds_Initialize(asn1SccOutOfBounds* pVal)
{
    *pVal = (asn1SccOutOfBounds) {
    .error_name = {0,
        {
        }
    },
    .min = 0.00000000000000000000E+000,
    .max = 0.00000000000000000000E+000,
    .value = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccOutOfBounds_IsConstraintValid(const asn1SccOutOfBounds* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->error_name, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->min, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->max, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->value, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccRigidBodyState_Initialize(asn1SccRigidBodyState* pVal)
{
    *pVal = (asn1SccRigidBodyState) {
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .sourceFrame = {0,
        {
        }
    },
    .targetFrame = {0,
        {
        }
    },
    .pos = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_position = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .orient = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_orientation = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .velocity = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_velocity = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .angular_velocity = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_angular_velocity = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccRigidBodyState_IsConstraintValid(const asn1SccRigidBodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->sourceFrame, pErrCode);
	    if (ret) {
	        ret = asn1SccT_String_IsConstraintValid(&pVal->targetFrame, pErrCode);
	        if (ret) {
	            ret = asn1SccPosition_IsConstraintValid(&pVal->pos, pErrCode);
	            if (ret) {
	                ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_position, pErrCode);
	                if (ret) {
	                    ret = asn1SccOrientation_IsConstraintValid(&pVal->orient, pErrCode);
	                    if (ret) {
	                        ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_orientation, pErrCode);
	                        if (ret) {
	                            ret = asn1SccVector3d_IsConstraintValid(&pVal->velocity, pErrCode);
	                            if (ret) {
	                                ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_velocity, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccVector3d_IsConstraintValid(&pVal->angular_velocity, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_angular_velocity, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWrenches_Initialize(asn1SccWrenches* pVal)
{
    *pVal = (asn1SccWrenches) {
    .vector_name = {0,
        {
        }
    },
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .wrenches = {    .nCount = 1,    .arr = 
        {
            {
                .timestamp = {
                    .microseconds = -9223372036854775807LL,
                    .usecPerSec = -2147483648LL
                },
                .force = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                },
                .torque = {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccWrenches_IsConstraintValid(const asn1SccWrenches* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->vector_name, pErrCode);
	if (ret) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	    if (ret) {
	        ret = asn1SccWrenches_wrenches_IsConstraintValid(&pVal->wrenches, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccInvalidName_Initialize(asn1SccInvalidName* pVal)
{
    *pVal = (asn1SccInvalidName) {
    .nameString = {0,
        {
        }
    }
};
}
#endif

 
flag asn1SccInvalidName_IsConstraintValid(const asn1SccInvalidName* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_String_IsConstraintValid(&pVal->nameString, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccUNIT_AXIS_Initialize(asn1SccUNIT_AXIS* pVal)
{
    *pVal = (asn1SccUNIT_AXIS) asn1Sccunit_x;
}
#endif

 
flag asn1SccUNIT_AXIS_IsConstraintValid(const asn1SccUNIT_AXIS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccunit_x) || (*pVal == asn1Sccunit_y)) || (*pVal == asn1Sccunit_z));
	*pErrCode = ret ? 0 : ERR_asn1SccUNIT_AXIS;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDEPTH_MEASUREMENT_STATE_Initialize(asn1SccDEPTH_MEASUREMENT_STATE* pVal)
{
    *pVal = (asn1SccDEPTH_MEASUREMENT_STATE) asn1Sccvalid_measurement;
}
#endif

 
flag asn1SccDEPTH_MEASUREMENT_STATE_IsConstraintValid(const asn1SccDEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == asn1Sccvalid_measurement) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_too_far)) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_too_near)) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_measurement_error));
	*pErrCode = ret ? 0 : ERR_asn1SccDEPTH_MEASUREMENT_STATE;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPROJECTION_TYPE_Initialize(asn1SccPROJECTION_TYPE* pVal)
{
    *pVal = (asn1SccPROJECTION_TYPE) asn1Sccpolar;
}
#endif

 
flag asn1SccPROJECTION_TYPE_IsConstraintValid(const asn1SccPROJECTION_TYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == asn1Sccpolar) || (*pVal == asn1Sccplanar));
	*pErrCode = ret ? 0 : ERR_asn1SccPROJECTION_TYPE;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_Initialize(asn1SccDepthMap* pVal)
{
    *pVal = (asn1SccDepthMap) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL,
                .usecPerSec = -2147483648LL
            }        
        }
    },
    .vertical_projection = asn1Sccpolar,
    .horizontal_projection = asn1Sccpolar,
    .vertical_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .horizontal_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .vertical_size = 0,
    .horizontal_size = 0,
    .distances = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .remissions = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccDepthMap_IsConstraintValid(const asn1SccDepthMap* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccDepthMap_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccPROJECTION_TYPE_IsConstraintValid(&pVal->vertical_projection, pErrCode);
	        if (ret) {
	            ret = asn1SccPROJECTION_TYPE_IsConstraintValid(&pVal->horizontal_projection, pErrCode);
	            if (ret) {
	                ret = asn1SccDepthMap_vertical_interval_IsConstraintValid(&pVal->vertical_interval, pErrCode);
	                if (ret) {
	                    ret = asn1SccDepthMap_horizontal_interval_IsConstraintValid(&pVal->horizontal_interval, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->vertical_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->horizontal_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccDepthMap_distances_IsConstraintValid(&pVal->distances, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccDepthMap_remissions_IsConstraintValid(&pVal->remissions, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccFrame_compressed_mode_t_Initialize(asn1SccFrame_compressed_mode_t* pVal)
{
    *pVal = (asn1SccFrame_compressed_mode_t) asn1Sccmode_compressed_undefined;
}
#endif

 
flag asn1SccFrame_compressed_mode_t_IsConstraintValid(const asn1SccFrame_compressed_mode_t* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == asn1Sccmode_compressed_undefined) || (*pVal == asn1SccFrame_compressed_mode_t_mode_pjpg));
	*pErrCode = ret ? 0 : ERR_asn1SccFrame_compressed_mode_t;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccCompressedFrame_Initialize(asn1SccCompressedFrame* pVal)
{
    *pVal = (asn1SccCompressedFrame) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .received_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .image = {    .nCount = 1,    .arr = 
        {
            0        
        }
    },
    .attributes = {    .nCount = 1,    .arr = 
        {
            {
                .data = {0,
                    {
                    }
                },
                .att_name = {0,
                    {
                    }
                }
            }        
        }
    },
    .datasize = {
        .width = 0,
        .height = 0
    },
    .frame_mode = asn1Sccmode_compressed_undefined,
    .frame_status = asn1Sccstatus_empty
};
}
#endif

 
flag asn1SccCompressedFrame_IsConstraintValid(const asn1SccCompressedFrame* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->received_time, pErrCode);
	    if (ret) {
	        ret = asn1SccCompressedFrame_image_IsConstraintValid(&pVal->image, pErrCode);
	        if (ret) {
	            ret = asn1SccCompressedFrame_attributes_IsConstraintValid(&pVal->attributes, pErrCode);
	            if (ret) {
	                ret = asn1SccFrame_size_t_IsConstraintValid(&pVal->datasize, pErrCode);
	                if (ret) {
	                    ret = asn1SccFrame_compressed_mode_t_IsConstraintValid(&pVal->frame_mode, pErrCode);
	                    if (ret) {
	                        ret = asn1SccFrame_status_t_IsConstraintValid(&pVal->frame_status, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccResolution_Initialize(asn1SccResolution* pVal)
{
    *pVal = (asn1SccResolution) asn1Sccseconds;
}
#endif

 
flag asn1SccResolution_IsConstraintValid(const asn1SccResolution* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccseconds) || (*pVal == asn1Sccmilliseconds)) || (*pVal == asn1Sccmicroseconds));
	*pErrCode = ret ? 0 : ERR_asn1SccResolution;

	return ret;
}

const asn1SccT_UInt32 maxSonarBeamSize = 60;

const asn1SccT_UInt32 maxJointLimitsSize = 60;

const asn1SccT_UInt32 frameMaxBytes = 2359296;

const asn1SccT_UInt32 frameMaxRows = 768;

const asn1SccT_UInt32 frameMaxCols = 1024;

const asn1SccT_UInt32 frameMaxAttributes = 5;

const asn1SccT_UInt32 maxJointTrajectorySize = 60;

const asn1SccT_UInt32 maxJointsTrajectorySize = 60;

const asn1SccT_UInt32 maxLaserScanSize = 60;

const asn1SccT_UInt32 maxSonarSize = 60;

const asn1SccT_UInt32 maxDistanceImageSize = 60;

const asn1SccT_UInt32 jointsNameLength = 30;

const asn1SccT_UInt32 jointsElementsMax = 30;

const asn1SccT_UInt32 vizkit3dPathMaxSize = 255;

const asn1SccT_UInt32 vizkit3dLabelMaxSize = 31;

const asn1SccT_UInt32 maxSize_T_String = 256;

const asn1SccT_UInt32 maxDepthMapSize = 60;

const asn1SccT_UInt32 maxCompressedFrameImageSize = 262144;

const asn1SccT_UInt32 maxCompressedFrameImageAttributes = 10;

const asn1SccT_UInt32 maxTrajectoryPoints = 50;

const asn1SccT_UInt32 maxPointcloudSize = 60;

const asn1SccT_UInt32 maxWrenchesSize = 60;

const asn1SccT_UInt32 maxSonarScanDataSize = 60;
