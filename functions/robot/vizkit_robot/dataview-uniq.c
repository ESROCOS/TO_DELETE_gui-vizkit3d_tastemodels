/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dataview-uniq.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Double_Initialize(asn1SccT_Double* pVal)
{
    *pVal = (asn1SccT_Double) 0.00000000000000000000E+000;
}
#endif

 
flag asn1SccT_Double_IsConstraintValid(const asn1SccT_Double* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-1.79769313486231570000E+308 <= *pVal && *pVal <= 1.79769313486231570000E+308);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Double;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector6d_Initialize(asn1SccVector6d* pVal)
{
    *pVal = (asn1SccVector6d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector6d_IsConstraintValid(const asn1SccVector6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccVector6d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector3d_Initialize(asn1SccVector3d* pVal)
{
    *pVal = (asn1SccVector3d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector3d_IsConstraintValid(const asn1SccVector3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccVector3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPosition_Initialize(asn1SccPosition* pVal)
{
    *pVal = (asn1SccPosition) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccPosition_IsConstraintValid(const asn1SccPosition* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPoint_Initialize(asn1SccPoint* pVal)
{
    *pVal = (asn1SccPoint) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccPoint_IsConstraintValid(const asn1SccPoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPointcloud_points_Initialize(asn1SccPointcloud_points* pVal)
{
    *pVal = (asn1SccPointcloud_points) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccPointcloud_points_IsConstraintValid(const asn1SccPointcloud_points* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxPointcloudSize);
	*pErrCode = ret ? 0 : ERR_asn1SccPointcloud_points;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccPoint_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccWaypoint_Initialize(asn1SccWaypoint* pVal)
{
    *pVal = (asn1SccWaypoint) {
    .position = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .heading = 0.00000000000000000000E+000,
    .tol_position = 0.00000000000000000000E+000,
    .tol_heading = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccWaypoint_IsConstraintValid(const asn1SccWaypoint* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->heading, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_position, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->tol_heading, pErrCode);
	        
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccQuaterniond_Initialize(asn1SccQuaterniond* pVal)
{
    *pVal = (asn1SccQuaterniond) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccQuaterniond_IsConstraintValid(const asn1SccQuaterniond* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccQuaterniond;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccOrientation_Initialize(asn1SccOrientation* pVal)
{
    *pVal = (asn1SccOrientation) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccOrientation_IsConstraintValid(const asn1SccOrientation* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccQuaterniond_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPose_Initialize(asn1SccPose* pVal)
{
    *pVal = (asn1SccPose) {
    .pos = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .orient = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccPose_IsConstraintValid(const asn1SccPose* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPosition_IsConstraintValid(&pVal->pos, pErrCode);
	if (ret) {
	    ret = asn1SccOrientation_IsConstraintValid(&pVal->orient, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVectorXd_Initialize(asn1SccVectorXd* pVal)
{
    *pVal = (asn1SccVectorXd) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVectorXd_IsConstraintValid(const asn1SccVectorXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 100);
	*pErrCode = ret ? 0 : ERR_asn1SccVectorXd;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector2d_Initialize(asn1SccVector2d* pVal)
{
    *pVal = (asn1SccVector2d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector2d_IsConstraintValid(const asn1SccVector2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccVector2d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPosition2D_Initialize(asn1SccPosition2D* pVal)
{
    *pVal = (asn1SccPosition2D) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccPosition2D_IsConstraintValid(const asn1SccPosition2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector2d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPose2D_Initialize(asn1SccPose2D* pVal)
{
    *pVal = (asn1SccPose2D) {
    .position = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .orientation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccPose2D_IsConstraintValid(const asn1SccPose2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPosition2D_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->orientation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVector4d_Initialize(asn1SccVector4d* pVal)
{
    *pVal = (asn1SccVector4d) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccVector4d_IsConstraintValid(const asn1SccVector4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccVector4d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPointcloud_colors_Initialize(asn1SccPointcloud_colors* pVal)
{
    *pVal = (asn1SccPointcloud_colors) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccPointcloud_colors_IsConstraintValid(const asn1SccPointcloud_colors* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxPointcloudSize);
	*pErrCode = ret ? 0 : ERR_asn1SccPointcloud_colors;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccVector4d_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAngleAxisd_Initialize(asn1SccAngleAxisd* pVal)
{
    *pVal = (asn1SccAngleAxisd) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccAngleAxisd_IsConstraintValid(const asn1SccAngleAxisd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccAngleAxisd;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTransform3d_elm_Initialize(asn1SccTransform3d_elm* pVal)
{
    *pVal = (asn1SccTransform3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccTransform3d_elm_IsConstraintValid(const asn1SccTransform3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccTransform3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTransform3d_Initialize(asn1SccTransform3d* pVal)
{
    *pVal = (asn1SccTransform3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccTransform3d_IsConstraintValid(const asn1SccTransform3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccTransform3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTransform3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix4d_elm_Initialize(asn1SccMatrix4d_elm* pVal)
{
    *pVal = (asn1SccMatrix4d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix4d_elm_IsConstraintValid(const asn1SccMatrix4d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix4d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix4d_Initialize(asn1SccMatrix4d* pVal)
{
    *pVal = (asn1SccMatrix4d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix4d_IsConstraintValid(const asn1SccMatrix4d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix4d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix4d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix2d_elm_Initialize(asn1SccMatrix2d_elm* pVal)
{
    *pVal = (asn1SccMatrix2d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix2d_elm_IsConstraintValid(const asn1SccMatrix2d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 2);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix2d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix2d_Initialize(asn1SccMatrix2d* pVal)
{
    *pVal = (asn1SccMatrix2d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix2d_IsConstraintValid(const asn1SccMatrix2d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 2);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix2d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix2d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccIsometry3d_elm_Initialize(asn1SccIsometry3d_elm* pVal)
{
    *pVal = (asn1SccIsometry3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccIsometry3d_elm_IsConstraintValid(const asn1SccIsometry3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccIsometry3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccIsometry3d_Initialize(asn1SccIsometry3d* pVal)
{
    *pVal = (asn1SccIsometry3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccIsometry3d_IsConstraintValid(const asn1SccIsometry3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccIsometry3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccIsometry3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrixXd_elm_Initialize(asn1SccMatrixXd_elm* pVal)
{
    *pVal = (asn1SccMatrixXd_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrixXd_elm_IsConstraintValid(const asn1SccMatrixXd_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 20);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrixXd_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrixXd_Initialize(asn1SccMatrixXd* pVal)
{
    *pVal = (asn1SccMatrixXd) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrixXd_IsConstraintValid(const asn1SccMatrixXd* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 20);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrixXd;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrixXd_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix3d_elm_Initialize(asn1SccMatrix3d_elm* pVal)
{
    *pVal = (asn1SccMatrix3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix3d_elm_IsConstraintValid(const asn1SccMatrix3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix3d_Initialize(asn1SccMatrix3d* pVal)
{
    *pVal = (asn1SccMatrix3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix3d_IsConstraintValid(const asn1SccMatrix3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 3);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix6d_elm_Initialize(asn1SccMatrix6d_elm* pVal)
{
    *pVal = (asn1SccMatrix6d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccMatrix6d_elm_IsConstraintValid(const asn1SccMatrix6d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix6d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMatrix6d_Initialize(asn1SccMatrix6d* pVal)
{
    *pVal = (asn1SccMatrix6d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccMatrix6d_IsConstraintValid(const asn1SccMatrix6d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 6);
	*pErrCode = ret ? 0 : ERR_asn1SccMatrix6d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMatrix6d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccCovariance_Initialize(asn1SccCovariance* pVal)
{
    *pVal = (asn1SccCovariance) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccCovariance_IsConstraintValid(const asn1SccCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccMatrix6d_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTransformWithCovariance_Initialize(asn1SccTransformWithCovariance* pVal)
{
    *pVal = (asn1SccTransformWithCovariance) {
    .translation = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .orientation = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccTransformWithCovariance_IsConstraintValid(const asn1SccTransformWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccPosition_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccQuaterniond_IsConstraintValid(&pVal->orientation, pErrCode);
	    if (ret) {
	        ret = asn1SccCovariance_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTwistWithCovariance_Initialize(asn1SccTwistWithCovariance* pVal)
{
    *pVal = (asn1SccTwistWithCovariance) {
    .vel = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .rot = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccTwistWithCovariance_IsConstraintValid(const asn1SccTwistWithCovariance* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccVector3d_IsConstraintValid(&pVal->vel, pErrCode);
	if (ret) {
	    ret = asn1SccVector3d_IsConstraintValid(&pVal->rot, pErrCode);
	    if (ret) {
	        ret = asn1SccCovariance_IsConstraintValid(&pVal->cov, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAffine3d_elm_Initialize(asn1SccAffine3d_elm* pVal)
{
    *pVal = (asn1SccAffine3d_elm) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccAffine3d_elm_IsConstraintValid(const asn1SccAffine3d_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccAffine3d_elm;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAffine3d_Initialize(asn1SccAffine3d* pVal)
{
    *pVal = (asn1SccAffine3d) {    .nCount = 1,    .arr = 
    {
        {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        }        
    }
};
}
#endif

 
flag asn1SccAffine3d_IsConstraintValid(const asn1SccAffine3d* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 4);
	*pErrCode = ret ? 0 : ERR_asn1SccAffine3d;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccAffine3d_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_horizontal_interval_Initialize(asn1SccDepthMap_horizontal_interval* pVal)
{
    *pVal = (asn1SccDepthMap_horizontal_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_horizontal_interval_IsConstraintValid(const asn1SccDepthMap_horizontal_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_horizontal_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_vertical_interval_Initialize(asn1SccDepthMap_vertical_interval* pVal)
{
    *pVal = (asn1SccDepthMap_vertical_interval) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_vertical_interval_IsConstraintValid(const asn1SccDepthMap_vertical_interval* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_vertical_interval;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPoseUpdateThreshold_Initialize(asn1SccPoseUpdateThreshold* pVal)
{
    *pVal = (asn1SccPoseUpdateThreshold) {
    .distance = 0.00000000000000000000E+000,
    .angle = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccPoseUpdateThreshold_IsConstraintValid(const asn1SccPoseUpdateThreshold* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->distance, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->angle, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMotion2D_Initialize(asn1SccMotion2D* pVal)
{
    *pVal = (asn1SccMotion2D) {
    .translation = 0.00000000000000000000E+000,
    .rotation = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccMotion2D_IsConstraintValid(const asn1SccMotion2D* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->translation, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->rotation, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAngle_Initialize(asn1SccAngle* pVal)
{
    *pVal = (asn1SccAngle) {
    .rad = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccAngle_IsConstraintValid(const asn1SccAngle* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->rad, pErrCode);


	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccAngleSegment_Initialize(asn1SccAngleSegment* pVal)
{
    *pVal = (asn1SccAngleSegment) {
    .width = 0.00000000000000000000E+000,
    .startRad = 0.00000000000000000000E+000,
    .endRad = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccAngleSegment_IsConstraintValid(const asn1SccAngleSegment* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->width, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->startRad, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->endRad, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Float_Initialize(asn1SccT_Float* pVal)
{
    *pVal = (asn1SccT_Float) 0.00000000000000000000E+000;
}
#endif

 
flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-3.40282346600000020000E+038 <= *pVal && *pVal <= 3.40282346600000020000E+038);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Float;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_remissions_Initialize(asn1SccDepthMap_remissions* pVal)
{
    *pVal = (asn1SccDepthMap_remissions) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_remissions_IsConstraintValid(const asn1SccDepthMap_remissions* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_remissions;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_distances_Initialize(asn1SccDepthMap_distances* pVal)
{
    *pVal = (asn1SccDepthMap_distances) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccDepthMap_distances_IsConstraintValid(const asn1SccDepthMap_distances* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_distances;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLaserScan_remission_Initialize(asn1SccLaserScan_remission* pVal)
{
    *pVal = (asn1SccLaserScan_remission) {    .nCount = 1,    .arr = 
    {
        0.00000000000000000000E+000        
    }
};
}
#endif

 
flag asn1SccLaserScan_remission_IsConstraintValid(const asn1SccLaserScan_remission* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxLaserScanSize);
	*pErrCode = ret ? 0 : ERR_asn1SccLaserScan_remission;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJointState_Initialize(asn1SccJointState* pVal)
{
    *pVal = (asn1SccJointState) {
    .position = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .effort = 0.00000000000000000000E+000,
    .raw = 0.00000000000000000000E+000,
    .acceleration = 0.00000000000000000000E+000
};
}
#endif

 
flag asn1SccJointState_IsConstraintValid(const asn1SccJointState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Double_IsConstraintValid(&pVal->position, pErrCode);
	if (ret) {
	    ret = asn1SccT_Float_IsConstraintValid(&pVal->speed, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Float_IsConstraintValid(&pVal->effort, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->raw, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->acceleration, pErrCode);
	            
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJoints_elements_Initialize(asn1SccJoints_elements* pVal)
{
    *pVal = (asn1SccJoints_elements) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccJoints_elements_IsConstraintValid(const asn1SccJoints_elements* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)jointsElementsMax);
	*pErrCode = ret ? 0 : ERR_asn1SccJoints_elements;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccJointState_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int16_Initialize(asn1SccT_Int16* pVal)
{
    *pVal = (asn1SccT_Int16) -32768;
}
#endif

 
flag asn1SccT_Int16_IsConstraintValid(const asn1SccT_Int16* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-32768 <= *pVal && *pVal <= 32767);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int16;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt16_Initialize(asn1SccT_UInt16* pVal)
{
    *pVal = (asn1SccT_UInt16) 0;
}
#endif

 
flag asn1SccT_UInt16_IsConstraintValid(const asn1SccT_UInt16* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 65535);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt16;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt64_Initialize(asn1SccT_UInt64* pVal)
{
    *pVal = (asn1SccT_UInt64) 0;
}
#endif

 
flag asn1SccT_UInt64_IsConstraintValid(const asn1SccT_UInt64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt64;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int64_Initialize(asn1SccT_Int64* pVal)
{
    *pVal = (asn1SccT_Int64) -9223372036854775807LL;
}
#endif

 
flag asn1SccT_Int64_IsConstraintValid(const asn1SccT_Int64* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-9223372036854775807LL <= *pVal && *pVal <= 9223372036854775807LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int64;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_String_Initialize(asn1SccT_String* pVal)
{
    *pVal = (asn1SccT_String) {0,
    {
    }
};
}
#endif

 
flag asn1SccT_String_IsConstraintValid(const asn1SccT_String* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)maxSize_T_String);
	*pErrCode = ret ? 0 : ERR_asn1SccT_String;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccUNIT_AXIS_Initialize(asn1SccUNIT_AXIS* pVal)
{
    *pVal = (asn1SccUNIT_AXIS) asn1Sccunit_x;
}
#endif

 
flag asn1SccUNIT_AXIS_IsConstraintValid(const asn1SccUNIT_AXIS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccunit_x) || (*pVal == asn1Sccunit_y)) || (*pVal == asn1Sccunit_z));
	*pErrCode = ret ? 0 : ERR_asn1SccUNIT_AXIS;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDEPTH_MEASUREMENT_STATE_Initialize(asn1SccDEPTH_MEASUREMENT_STATE* pVal)
{
    *pVal = (asn1SccDEPTH_MEASUREMENT_STATE) asn1Sccvalid_measurement;
}
#endif

 
flag asn1SccDEPTH_MEASUREMENT_STATE_IsConstraintValid(const asn1SccDEPTH_MEASUREMENT_STATE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((*pVal == asn1Sccvalid_measurement) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_too_far)) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_too_near)) || (*pVal == asn1SccDEPTH_MEASUREMENT_STATE_measurement_error));
	*pErrCode = ret ? 0 : ERR_asn1SccDEPTH_MEASUREMENT_STATE;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPROJECTION_TYPE_Initialize(asn1SccPROJECTION_TYPE* pVal)
{
    *pVal = (asn1SccPROJECTION_TYPE) asn1Sccpolar;
}
#endif

 
flag asn1SccPROJECTION_TYPE_IsConstraintValid(const asn1SccPROJECTION_TYPE* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((*pVal == asn1Sccpolar) || (*pVal == asn1Sccplanar));
	*pErrCode = ret ? 0 : ERR_asn1SccPROJECTION_TYPE;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccResolution_Initialize(asn1SccResolution* pVal)
{
    *pVal = (asn1SccResolution) asn1Sccseconds;
}
#endif

 
flag asn1SccResolution_IsConstraintValid(const asn1SccResolution* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (((*pVal == asn1Sccseconds) || (*pVal == asn1Sccmilliseconds)) || (*pVal == asn1Sccmicroseconds));
	*pErrCode = ret ? 0 : ERR_asn1SccResolution;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
    *pVal = (asn1SccT_Int32) -2147483648LL;
}
#endif

 
flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-2147483648LL <= *pVal && *pVal <= 2147483647LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int32;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccTime_Initialize(asn1SccTime* pVal)
{
    *pVal = (asn1SccTime) {
    .microseconds = -9223372036854775807LL,
    .usecPerSec = -2147483648LL
};
}
#endif

 
flag asn1SccTime_IsConstraintValid(const asn1SccTime* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccT_Int64_IsConstraintValid(&pVal->microseconds, pErrCode);
	if (ret) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->usecPerSec, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_timestamps_Initialize(asn1SccDepthMap_timestamps* pVal)
{
    *pVal = (asn1SccDepthMap_timestamps) {    .nCount = 1,    .arr = 
    {
        {
            .microseconds = -9223372036854775807LL,
            .usecPerSec = -2147483648LL
        }        
    }
};
}
#endif

 
flag asn1SccDepthMap_timestamps_IsConstraintValid(const asn1SccDepthMap_timestamps* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxDepthMapSize);
	*pErrCode = ret ? 0 : ERR_asn1SccDepthMap_timestamps;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccTime_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccPointcloud_Initialize(asn1SccPointcloud* pVal)
{
    *pVal = (asn1SccPointcloud) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .points = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .colors = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccPointcloud_IsConstraintValid(const asn1SccPointcloud* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccPointcloud_points_IsConstraintValid(&pVal->points, pErrCode);
	    if (ret) {
	        ret = asn1SccPointcloud_colors_IsConstraintValid(&pVal->colors, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccRigidBodyState_Initialize(asn1SccRigidBodyState* pVal)
{
    *pVal = (asn1SccRigidBodyState) {
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .sourceFrame = {0,
        {
        }
    },
    .targetFrame = {0,
        {
        }
    },
    .pos = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_position = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .orient = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_orientation = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .velocity = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_velocity = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    },
    .angular_velocity = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .cov_angular_velocity = {    .nCount = 1,    .arr = 
        {
            {    .nCount = 1,    .arr = 
                {
                    0.00000000000000000000E+000        
                }
            }        
        }
    }
};
}
#endif

 
flag asn1SccRigidBodyState_IsConstraintValid(const asn1SccRigidBodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	if (ret) {
	    ret = asn1SccT_String_IsConstraintValid(&pVal->sourceFrame, pErrCode);
	    if (ret) {
	        ret = asn1SccT_String_IsConstraintValid(&pVal->targetFrame, pErrCode);
	        if (ret) {
	            ret = asn1SccPosition_IsConstraintValid(&pVal->pos, pErrCode);
	            if (ret) {
	                ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_position, pErrCode);
	                if (ret) {
	                    ret = asn1SccOrientation_IsConstraintValid(&pVal->orient, pErrCode);
	                    if (ret) {
	                        ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_orientation, pErrCode);
	                        if (ret) {
	                            ret = asn1SccVector3d_IsConstraintValid(&pVal->velocity, pErrCode);
	                            if (ret) {
	                                ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_velocity, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccVector3d_IsConstraintValid(&pVal->angular_velocity, pErrCode);
	                                    if (ret) {
	                                        ret = asn1SccMatrix3d_IsConstraintValid(&pVal->cov_angular_velocity, pErrCode);
	                                    
	                                    }
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccBodyState_Initialize(asn1SccBodyState* pVal)
{
    *pVal = (asn1SccBodyState) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .pose = {
        .translation = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .orientation = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .cov = {    .nCount = 1,    .arr = 
            {
                {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }        
            }
        }
    },
    .velocity = {
        .vel = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .rot = {    .nCount = 1,    .arr = 
            {
                0.00000000000000000000E+000        
            }
        },
        .cov = {    .nCount = 1,    .arr = 
            {
                {    .nCount = 1,    .arr = 
                    {
                        0.00000000000000000000E+000        
                    }
                }        
            }
        }
    }
};
}
#endif

 
flag asn1SccBodyState_IsConstraintValid(const asn1SccBodyState* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccTransformWithCovariance_IsConstraintValid(&pVal->pose, pErrCode);
	    if (ret) {
	        ret = asn1SccTwistWithCovariance_IsConstraintValid(&pVal->velocity, pErrCode);
	    
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLaserScan_ranges_Initialize(asn1SccLaserScan_ranges* pVal)
{
    *pVal = (asn1SccLaserScan_ranges) {    .nCount = 1,    .arr = 
    {
        -2147483648LL        
    }
};
}
#endif

 
flag asn1SccLaserScan_ranges_IsConstraintValid(const asn1SccLaserScan_ranges* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxLaserScanSize);
	*pErrCode = ret ? 0 : ERR_asn1SccLaserScan_ranges;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_Int32_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
    *pVal = (asn1SccT_UInt32) 0;
}
#endif

 
flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 4294967295LL);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt32;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccDepthMap_Initialize(asn1SccDepthMap* pVal)
{
    *pVal = (asn1SccDepthMap) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .timestamps = {    .nCount = 1,    .arr = 
        {
            {
                .microseconds = -9223372036854775807LL,
                .usecPerSec = -2147483648LL
            }        
        }
    },
    .vertical_projection = asn1Sccpolar,
    .horizontal_projection = asn1Sccpolar,
    .vertical_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .horizontal_interval = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .vertical_size = 0,
    .horizontal_size = 0,
    .distances = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    },
    .remissions = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccDepthMap_IsConstraintValid(const asn1SccDepthMap* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccDepthMap_timestamps_IsConstraintValid(&pVal->timestamps, pErrCode);
	    if (ret) {
	        ret = asn1SccPROJECTION_TYPE_IsConstraintValid(&pVal->vertical_projection, pErrCode);
	        if (ret) {
	            ret = asn1SccPROJECTION_TYPE_IsConstraintValid(&pVal->horizontal_projection, pErrCode);
	            if (ret) {
	                ret = asn1SccDepthMap_vertical_interval_IsConstraintValid(&pVal->vertical_interval, pErrCode);
	                if (ret) {
	                    ret = asn1SccDepthMap_horizontal_interval_IsConstraintValid(&pVal->horizontal_interval, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->vertical_size, pErrCode);
	                        if (ret) {
	                            ret = asn1SccT_UInt32_IsConstraintValid(&pVal->horizontal_size, pErrCode);
	                            if (ret) {
	                                ret = asn1SccDepthMap_distances_IsConstraintValid(&pVal->distances, pErrCode);
	                                if (ret) {
	                                    ret = asn1SccDepthMap_remissions_IsConstraintValid(&pVal->remissions, pErrCode);
	                                
	                                }
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLaserScan_Initialize(asn1SccLaserScan* pVal)
{
    *pVal = (asn1SccLaserScan) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .start_angle = 0.00000000000000000000E+000,
    .angular_resolution = 0.00000000000000000000E+000,
    .speed = 0.00000000000000000000E+000,
    .ranges = {    .nCount = 1,    .arr = 
        {
            -2147483648LL        
        }
    },
    .minRange = 0,
    .maxRange = 0,
    .remission = {    .nCount = 1,    .arr = 
        {
            0.00000000000000000000E+000        
        }
    }
};
}
#endif

 
flag asn1SccLaserScan_IsConstraintValid(const asn1SccLaserScan* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccT_Double_IsConstraintValid(&pVal->start_angle, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->angular_resolution, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Double_IsConstraintValid(&pVal->speed, pErrCode);
	            if (ret) {
	                ret = asn1SccLaserScan_ranges_IsConstraintValid(&pVal->ranges, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_UInt32_IsConstraintValid(&pVal->minRange, pErrCode);
	                    if (ret) {
	                        ret = asn1SccT_UInt32_IsConstraintValid(&pVal->maxRange, pErrCode);
	                        if (ret) {
	                            ret = asn1SccLaserScan_remission_IsConstraintValid(&pVal->remission, pErrCode);
	                        
	                        }
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
    *pVal = (asn1SccT_Int8) -128;
}
#endif

 
flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (-128 <= *pVal && *pVal <= 127);
	*pErrCode = ret ? 0 : ERR_asn1SccT_Int8;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
    *pVal = (asn1SccT_UInt8) 0;
}
#endif

 
flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (*pVal <= 255);
	*pErrCode = ret ? 0 : ERR_asn1SccT_UInt8;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonarBeam_beam_Initialize(asn1SccSonarBeam_beam* pVal)
{
    *pVal = (asn1SccSonarBeam_beam) {    .nCount = 1,    .arr = 
    {
        0        
    }
};
}
#endif

 
flag asn1SccSonarBeam_beam_IsConstraintValid(const asn1SccSonarBeam_beam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= (int)maxSonarBeamSize);
	*pErrCode = ret ? 0 : ERR_asn1SccSonarBeam_beam;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccT_UInt8_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSonarBeam_Initialize(asn1SccSonarBeam* pVal)
{
    *pVal = (asn1SccSonarBeam) {
    .ref_time = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .bearing = {
        .rad = 0.00000000000000000000E+000
    },
    .sampling_interval = 0.00000000000000000000E+000,
    .speed_of_sound = 0.00000000000000000000E+000,
    .beamwidth_horizontal = 0.00000000000000000000E+000,
    .beamwidth_vertical = 0.00000000000000000000E+000,
    .beam = {    .nCount = 1,    .arr = 
        {
            0        
        }
    }
};
}
#endif

 
flag asn1SccSonarBeam_IsConstraintValid(const asn1SccSonarBeam* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->ref_time, pErrCode);
	if (ret) {
	    ret = asn1SccAngle_IsConstraintValid(&pVal->bearing, pErrCode);
	    if (ret) {
	        ret = asn1SccT_Double_IsConstraintValid(&pVal->sampling_interval, pErrCode);
	        if (ret) {
	            ret = asn1SccT_Float_IsConstraintValid(&pVal->speed_of_sound, pErrCode);
	            if (ret) {
	                ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_horizontal, pErrCode);
	                if (ret) {
	                    ret = asn1SccT_Float_IsConstraintValid(&pVal->beamwidth_vertical, pErrCode);
	                    if (ret) {
	                        ret = asn1SccSonarBeam_beam_IsConstraintValid(&pVal->beam, pErrCode);
	                    
	                    }
	                }
	            }
	        }
	    }
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
    *pVal = (asn1SccT_Boolean) FALSE;
}
#endif

 
flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccLASER_RANGE_ERRORS_Initialize(asn1SccLASER_RANGE_ERRORS* pVal)
{
    *pVal = (asn1SccLASER_RANGE_ERRORS) asn1SccLASER_RANGE_ERRORS_too_far;
}
#endif

 
flag asn1SccLASER_RANGE_ERRORS_IsConstraintValid(const asn1SccLASER_RANGE_ERRORS* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = ((((((*pVal == asn1SccLASER_RANGE_ERRORS_too_far) || (*pVal == asn1SccLASER_RANGE_ERRORS_too_near)) || (*pVal == asn1SccLASER_RANGE_ERRORS_measurement_error)) || (*pVal == asn1Sccother_range_errors)) || (*pVal == asn1Sccmax_range_error)) || (*pVal == asn1Sccend_laser_range_errors));
	*pErrCode = ret ? 0 : ERR_asn1SccLASER_RANGE_ERRORS;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVizkitFilePath_Initialize(asn1SccVizkitFilePath pVal)
{
    static asn1SccVizkitFilePath ret = 
        "";
    strcpy(pVal, ret);
}
#endif

 
flag asn1SccVizkitFilePath_IsConstraintValid(const asn1SccVizkitFilePath pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= strlen(pVal) && strlen(pVal) <= (int)vizkit3dPathMaxSize);
	*pErrCode = ret ? 0 : ERR_asn1SccVizkitFilePath;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccVizkitPluginLabel_Initialize(asn1SccVizkitPluginLabel pVal)
{
    static asn1SccVizkitPluginLabel ret = 
        " ";
    strcpy(pVal, ret);
}
#endif

 
flag asn1SccVizkitPluginLabel_IsConstraintValid(const asn1SccVizkitPluginLabel pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= strlen(pVal) && strlen(pVal) <= (int)vizkit3dLabelMaxSize);
	*pErrCode = ret ? 0 : ERR_asn1SccVizkitPluginLabel;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJoints_names_elm_Initialize(asn1SccJoints_names_elm* pVal)
{
    *pVal = (asn1SccJoints_names_elm) {0,
    {
    }
};
}
#endif

 
flag asn1SccJoints_names_elm_IsConstraintValid(const asn1SccJoints_names_elm* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)jointsNameLength);
	*pErrCode = ret ? 0 : ERR_asn1SccJoints_names_elm;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJoints_names_Initialize(asn1SccJoints_names* pVal)
{
    *pVal = (asn1SccJoints_names) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccJoints_names_IsConstraintValid(const asn1SccJoints_names* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= (int)jointsElementsMax);
	*pErrCode = ret ? 0 : ERR_asn1SccJoints_names;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccJoints_names_elm_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccJoints_Initialize(asn1SccJoints* pVal)
{
    *pVal = (asn1SccJoints) {
    .timestamp = {
        .microseconds = -9223372036854775807LL,
        .usecPerSec = -2147483648LL
    },
    .names = {    .nCount = 0,    .arr = 
        {
            
        }
    },
    .elements = {    .nCount = 0,    .arr = 
        {
            
        }
    }
};
}
#endif

 
flag asn1SccJoints_IsConstraintValid(const asn1SccJoints* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccTime_IsConstraintValid(&pVal->timestamp, pErrCode);
	if (ret) {
	    ret = asn1SccJoints_names_IsConstraintValid(&pVal->names, pErrCode);
	    if (ret) {
	        ret = asn1SccJoints_elements_IsConstraintValid(&pVal->elements, pErrCode);
	    
	    }
	}

	return ret;
}

const asn1SccT_UInt32 maxSize_T_String = 256;

const asn1SccT_UInt32 maxDepthMapSize = 60;

const asn1SccT_UInt32 maxSonarBeamSize = 60;

const asn1SccT_UInt32 maxPointcloudSize = 60;

const asn1SccT_UInt32 maxLaserScanSize = 60;

const asn1SccT_UInt32 vizkit3dPathMaxSize = 255;

const asn1SccT_UInt32 vizkit3dLabelMaxSize = 31;

const asn1SccT_UInt32 jointsNameLength = 25;

const asn1SccT_UInt32 jointsElementsMax = 30;
